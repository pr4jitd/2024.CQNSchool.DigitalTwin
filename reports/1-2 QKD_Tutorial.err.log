Traceback (most recent call last):
  File "/Users/prajitd/.pyenv/versions/3.12.1/lib/python3.12/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Users/prajitd/.pyenv/versions/3.12.1/lib/python3.12/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/prajitd/.pyenv/versions/3.12.1/lib/python3.12/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/prajitd/.pyenv/versions/3.12.1/lib/python3.12/asyncio/base_events.py", line 684, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/Users/prajitd/.pyenv/versions/3.12.1/lib/python3.12/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/Users/prajitd/.pyenv/versions/3.12.1/lib/python3.12/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Users/prajitd/.pyenv/versions/3.12.1/lib/python3.12/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
title="BB84Simulator"

from prettytable import PrettyTable
import qutip as qt
import random

class BB84Simulation:
    def __init__(self, N_ch=30):
        self.N_ch = N_ch
        self.H = qt.basis(2, 0)
        self.V = qt.basis(2, 1)
        self.D = 1 / (2**0.5) * (qt.basis(2, 0) + qt.basis(2, 1))
        self.A = 1 / (2**0.5) * (qt.basis(2, 0) - qt.basis(2, 1))
        self.states = {'H': self.H, 'V': self.V, 'D': self.D, 'A': self.A}
        self.bases = {'+': ['H', 'V'], 'x': ['D', 'A']}

    def run_simulation(self):
        alice_bits, alice_bases = self.generate_random_bits_and_bases()
        alice_states = [self.states[self.bases[base][bit]] for base, bit in zip(alice_bases, alice_bits)]
        bob_bases = [random.choice(list(self.bases.keys())) for _ in range(self.N_ch)]

        bob_bits, key, mismatch_bits = self.compute_bob_bits_and_key(alice_bits, alice_states, alice_bases, bob_bases)

        error_rate = self.compute_error_rate(key, mismatch_bits)
        self.display_table(alice_bits, alice_bases, bob_bases, bob_bits, key)
        print("Distilled key: ", key)
        print("Error rate: {:.2f}%".format(error_rate * 100))
        return key

    def generate_random_bits_and_bases(self):
        alice_bits = [random.choice([0, 1]) for _ in range(self.N_ch)]
        alice_bases = [random.choice(list(self.bases.keys())) for _ in range(self.N_ch)]
        return alice_bits, alice_bases

    def compute_bob_bits_and_key(self, alice_bits, alice_states, alice_bases, bob_bases):
        bob_bits = []
        key = []
        mismatch_bits = 0
        for i in range(self.N_ch):
            if alice_bases[i] == bob_bases[i]:
                if alice_states[i] == self.states[self.bases[bob_bases[i]][0]]:
                    bob_bits.append(0)
                else:
                    bob_bits.append(1)
                if alice_bits[i] != bob_bits[-1]:
                    mismatch_bits += 1
                key.append(bob_bits[-1])
            else:
                bob_bits.append(random.choice([0, 1]))
        return bob_bits, key, mismatch_bits

    def compute_error_rate(self, key, mismatch_bits):
        return mismatch_bits / len(key) if key else 0

    def display_table(self, alice_bits, alice_bases, bob_bases, bob_bits, key):
        table = PrettyTable()
        table.field_names = ["Channel", "Alice's Bit", "Alice's Base", "Bob's Base", "Bob's Measured Bit", "Key Bit"]
        for i in range(self.N_ch):
            table.add_row([i+1, alice_bits[i], alice_bases[i], bob_bases[i], bob_bits[i], bob_bits[i] if alice_bases[i] == bob_bases[i] else "X"])
        print(table)

# Create simulation
epoch = [BB84Simulation() for _ in range(1)]

# Run simulations
for trial in epoch:
    trial.run_simulation()

------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mModuleNotFoundError[0m                       Traceback (most recent call last)
Cell [0;32mIn[1], line 4[0m
[1;32m      1[0m title[38;5;241m=[39m[38;5;124m"[39m[38;5;124mBB84Simulator[39m[38;5;124m"[39m
[1;32m      3[0m [38;5;28;01mfrom[39;00m [38;5;21;01mprettytable[39;00m [38;5;28;01mimport[39;00m PrettyTable
[0;32m----> 4[0m [38;5;28;01mimport[39;00m [38;5;21;01mqutip[39;00m [38;5;28;01mas[39;00m [38;5;21;01mqt[39;00m
[1;32m      5[0m [38;5;28;01mimport[39;00m [38;5;21;01mrandom[39;00m
[1;32m      7[0m [38;5;28;01mclass[39;00m [38;5;21;01mBB84Simulation[39;00m:

[0;31mModuleNotFoundError[0m: No module named 'qutip'

